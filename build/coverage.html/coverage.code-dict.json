{"/home/travis/build/npmtest/node-npmtest-node-pre-gyp/test.js":"/* istanbul instrument in package npmtest_node_pre_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/lib.npmtest_node_pre_gyp.js":"/* istanbul instrument in package npmtest_node_pre_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_pre_gyp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_pre_gyp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-pre-gyp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_pre_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_pre_gyp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_pre_gyp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_pre_gyp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_pre_gyp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_pre_gyp.__dirname + '/lib.npmtest_node_pre_gyp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/node-pre-gyp.js":"\"use strict\";\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports;\n\n/**\n * Module dependencies.\n */\n\nvar path = require('path');\nvar nopt = require('nopt');\nvar log = require('npmlog');\nlog.disableProgress();\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar commands = [\n      'clean',\n      'install',\n      'reinstall',\n      'build',\n      'rebuild',\n      'package',\n      'testpackage',\n      'publish',\n      'unpublish',\n      'info',\n      'testbinary',\n      'reveal',\n      'configure'\n    ];\nvar aliases = {};\n\n// differentiate node-pre-gyp's logs from npm's\nlog.heading = 'node-pre-gyp';\n\nexports.find = require('./pre-binding').find;\n\nfunction Run() {\n  var self = this;\n\n  this.commands = {};\n\n  commands.forEach(function (command) {\n    self.commands[command] = function (argv, callback) {\n      log.verbose('command', command, argv);\n      return require('./' + command)(self, argv, callback);\n    };\n  });\n}\ninherits(Run, EE);\nexports.Run = Run;\nvar proto = Run.prototype;\n\n/**\n * Export the contents of the package.json.\n */\n\nproto.package = require('../package.json');\n\n/**\n * nopt configuration definitions\n */\n\nproto.configDefs = {\n    help: Boolean,     // everywhere\n    arch: String,      // 'configure'\n    debug: Boolean,    // 'build'\n    directory: String, // bin\n    proxy: String,     // 'install'\n    loglevel: String,  // everywhere\n};\n\n/**\n * nopt shorthands\n */\n\nproto.shorthands = {\n    release: '--no-debug',\n    C: '--directory',\n    debug: '--debug',\n    j: '--jobs',\n    silent: '--loglevel=silent',\n    silly: '--loglevel=silly',\n    verbose: '--loglevel=verbose',\n};\n\n/**\n * expose the command aliases for the bin file to use.\n */\n\nproto.aliases = aliases;\n\n/**\n * Parses the given argv array and sets the 'opts',\n * 'argv' and 'command' properties.\n */\n\nproto.parseArgv = function parseOpts (argv) {\n  this.opts = nopt(this.configDefs, this.shorthands, argv);\n  this.argv = this.opts.argv.remain.slice();\n  var commands = this.todo = [];\n\n  // create a copy of the argv array with aliases mapped\n  argv = this.argv.map(function (arg) {\n    // is this an alias?\n    if (arg in this.aliases) {\n      arg = this.aliases[arg];\n    }\n    return arg;\n  }, this);\n\n  // process the mapped args into \"command\" objects (\"name\" and \"args\" props)\n  argv.slice().forEach(function (arg) {\n    if (arg in this.commands) {\n      var args = argv.splice(0, argv.indexOf(arg));\n      argv.shift();\n      if (commands.length > 0) {\n        commands[commands.length - 1].args = args;\n      }\n      commands.push({ name: arg, args: [] });\n    }\n  }, this);\n  if (commands.length > 0) {\n    commands[commands.length - 1].args = argv.splice(0);\n  }\n\n  // support for inheriting config env variables from npm\n  var npm_config_prefix = 'npm_config_';\n  Object.keys(process.env).forEach(function (name) {\n    if (name.indexOf(npm_config_prefix) !== 0) return;\n    var val = process.env[name];\n    if (name === npm_config_prefix + 'loglevel') {\n      log.level = val;\n    } else {\n      // add the user-defined options to the config\n      name = name.substring(npm_config_prefix.length);\n      // avoid npm argv clobber already present args\n      // which avoids problem of 'npm test' calling\n      // script that runs unique npm install commands\n      if (name === 'argv') {\n         if (this.opts.argv &&\n             this.opts.argv.remain &&\n             this.opts.argv.remain.length) {\n            // do nothing\n         } else {\n            this.opts[name] = val;\n         }\n      } else {\n        this.opts[name] = val;\n      }\n    }\n  }, this);\n\n  if (this.opts.loglevel) {\n    log.level = this.opts.loglevel;\n  }\n  log.resume();\n};\n\n/**\n * Returns the usage instructions for node-pre-gyp.\n */\n\nproto.usage = function usage () {\n  var str = [\n      '',\n      '  Usage: node-pre-gyp <command> [options]',\n      '',\n      '  where <command> is one of:',\n      commands.map(function (c) {\n        return '    - ' + c + ' - ' + require('./' + c).usage;\n      }).join('\\n'),\n      '',\n      'node-pre-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'),\n      'node@' + process.versions.node\n  ].join('\\n');\n  return str;\n};\n\n/**\n * Version number getter.\n */\n\nObject.defineProperty(proto, 'version', {\n    get: function () {\n      return this.package.version;\n    },\n    enumerable: true\n});\n\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/pre-binding.js":"\"use strict\";\n\nvar versioning = require('../lib/util/versioning.js');\nvar existsSync = require('fs').existsSync || require('path').existsSync;\nvar path = require('path');\n\nmodule.exports = exports;\n\nexports.usage = 'Finds the require path for the node-pre-gyp installed module';\n\nexports.validate = function(package_json) {\n    versioning.validate_config(package_json);\n};\n\nexports.find = function(package_json_path,opts) {\n   if (!existsSync(package_json_path)) {\n        throw new Error(\"package.json does not exist at \" + package_json_path);\n   }\n   var package_json = require(package_json_path);\n   versioning.validate_config(package_json);\n   opts = opts || {};\n   if (!opts.module_root) opts.module_root = path.dirname(package_json_path);\n   var meta = versioning.evaluate(package_json,opts);\n   return meta.module;\n};\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/util/versioning.js":"\"use strict\";\n\nmodule.exports = exports;\n\nvar path = require('path');\nvar semver = require('semver');\nvar url = require('url');\n\nvar abi_crosswalk;\n\n// This is used for unit testing to provide a fake\n// ABI crosswalk that emulates one that is not updated\n// for the current version\nif (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {\n    abi_crosswalk = require(process.env.NODE_PRE_GYP_ABI_CROSSWALK);\n} else {\n    abi_crosswalk = require('./abi_crosswalk.json');\n}\n\nfunction get_electron_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_electron_abi requires valid runtime arg\");\n    }\n    if (typeof target_version === 'undefined') {\n        // erroneous CLI call\n        throw new Error(\"Empty target version is not supported if electron is the target.\");\n    }\n    // Electron guarantees that patch version update won't break native modules.\n    var sem_ver = semver.parse(target_version);\n    return runtime + '-v' + sem_ver.major + '.' + sem_ver.minor;\n}\nmodule.exports.get_electron_abi = get_electron_abi;\n\nfunction get_node_webkit_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_node_webkit_abi requires valid runtime arg\");\n    }\n    if (typeof target_version === 'undefined') {\n        // erroneous CLI call\n        throw new Error(\"Empty target version is not supported if node-webkit is the target.\");\n    }\n    return runtime + '-v' + target_version;\n}\nmodule.exports.get_node_webkit_abi = get_node_webkit_abi;\n\nfunction get_node_abi(runtime, versions) {\n    if (!runtime) {\n        throw new Error(\"get_node_abi requires valid runtime arg\");\n    }\n    if (!versions) {\n        throw new Error(\"get_node_abi requires valid process.versions object\");\n    }\n    var sem_ver = semver.parse(versions.node);\n    if (sem_ver.major === 0 && sem_ver.minor % 2) { // odd series\n        // https://github.com/mapbox/node-pre-gyp/issues/124\n        return runtime+'-v'+versions.node;\n    } else {\n        // process.versions.modules added in >= v0.10.4 and v0.11.7\n        // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e\n        return versions.modules ? runtime+'-v' + (+versions.modules) :\n            'v8-' + versions.v8.split('.').slice(0,2).join('.');\n    }\n}\nmodule.exports.get_node_abi = get_node_abi;\n\nfunction get_runtime_abi(runtime, target_version) {\n    if (!runtime) {\n        throw new Error(\"get_runtime_abi requires valid runtime arg\");\n    }\n    if (runtime === 'node-webkit') {\n        return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);\n    } else if (runtime === 'electron') {\n        return get_electron_abi(runtime, target_version || process.versions.electron);\n    } else {\n        if (runtime != 'node') {\n            throw new Error(\"Unknown Runtime: '\" + runtime + \"'\");\n        }\n        if (!target_version) {\n            return get_node_abi(runtime,process.versions);\n        } else {\n            var cross_obj;\n            // abi_crosswalk generated with ./scripts/abi_crosswalk.js\n            if (abi_crosswalk[target_version]) {\n                cross_obj = abi_crosswalk[target_version];\n            } else {\n                var target_parts = target_version.split('.').map(function(i) { return +i; });\n                if (target_parts.length != 3) { // parse failed\n                    throw new Error(\"Unknown target version: \" + target_version);\n                }\n                /*\n                    The below code tries to infer the last known ABI compatible version\n                    that we have recorded in the abi_crosswalk.json when an exact match\n                    is not possible. The reasons for this to exist are complicated:\n\n                       - We support passing --target to be able to allow developers to package binaries for versions of node\n                         that are not the same one as they are running. This might also be used in combination with the\n                         --target_arch or --target_platform flags to also package binaries for alternative platforms\n                       - When --target is passed we can't therefore determine the ABI (process.versions.modules) from the node\n                         version that is running in memory\n                       - So, therefore node-pre-gyp keeps an \"ABI crosswalk\" (lib/util/abi_crosswalk.json) to be able to look\n                         this info up for all versions\n                       - But we cannot easily predict what the future ABI will be for released versions\n                       - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly\n                         by being fully available at install time.\n                       - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release\n                         need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if\n                         you want the `--target` flag to keep working for the latest version\n                       - Which is impractical ^^\n                       - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.\n\n                    In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that\n                    only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be\n                    ABI compatible with v0.10.33).\n\n                    TODO: use semver module instead of custom version parsing\n                */\n                var major = target_parts[0];\n                var minor = target_parts[1];\n                var patch = target_parts[2];\n                // io.js: yeah if node.js ever releases 1.x this will break\n                // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616\n                if (major === 1) {\n                    // look for last release that is the same major version\n                    // e.g. we assume io.js 1.x is ABI compatible with >= 1.0.0\n                    while (true) {\n                        if (minor > 0) --minor;\n                        if (patch > 0) --patch;\n                        var new_iojs_target = '' + major + '.' + minor + '.' + patch;\n                        if (abi_crosswalk[new_iojs_target]) {\n                            cross_obj = abi_crosswalk[new_iojs_target];\n                            console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);\n                            console.log('Warning: but node-pre-gyp successfully choose ' + new_iojs_target + ' as ABI compatible target');\n                            break;\n                        }\n                        if (minor === 0 && patch === 0) {\n                            break;\n                        }\n                    }\n                } else if (major === 0) { // node.js\n                    if (target_parts[1] % 2 === 0) { // for stable/even node.js series\n                        // look for the last release that is the same minor release\n                        // e.g. we assume node 0.10.x is ABI compatible with >= 0.10.0\n                        while (--patch > 0) {\n                            var new_node_target = '' + major + '.' + minor + '.' + patch;\n                            if (abi_crosswalk[new_node_target]) {\n                                cross_obj = abi_crosswalk[new_node_target];\n                                console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);\n                                console.log('Warning: but node-pre-gyp successfully choose ' + new_node_target + ' as ABI compatible target');\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!cross_obj) {\n                throw new Error(\"Unsupported target version: \" + target_version);\n            }\n            // emulate process.versions\n            var versions_obj = {\n                node: target_version,\n                v8: cross_obj.v8+'.0',\n                // abi_crosswalk uses 1 for node versions lacking process.versions.modules\n                // process.versions.modules added in >= v0.10.4 and v0.11.7\n                modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined\n            };\n            return get_node_abi(runtime, versions_obj);\n        }\n    }\n}\nmodule.exports.get_runtime_abi = get_runtime_abi;\n\nvar required_parameters = [\n    'module_name',\n    'module_path',\n    'host'\n];\n\nfunction validate_config(package_json) {\n    var msg = package_json.name + ' package.json is not node-pre-gyp ready:\\n';\n    var missing = [];\n    if (!package_json.main) {\n        missing.push('main');\n    }\n    if (!package_json.version) {\n        missing.push('version');\n    }\n    if (!package_json.name) {\n        missing.push('name');\n    }\n    if (!package_json.binary) {\n        missing.push('binary');\n    }\n    var o = package_json.binary;\n    required_parameters.forEach(function(p) {\n        if (missing.indexOf('binary') > -1) {\n            missing.pop('binary');\n        }\n        if (!o || o[p] === undefined) {\n            missing.push('binary.' + p);\n        }\n    });\n    if (missing.length >= 1) {\n        throw new Error(msg+\"package.json must declare these properties: \\n\" + missing.join('\\n'));\n    }\n    if (o) {\n        // enforce https over http\n        var protocol = url.parse(o.host).protocol;\n        if (protocol === 'http:') {\n            throw new Error(\"'host' protocol (\"+protocol+\") is invalid - only 'https:' is accepted\");\n        }\n    }\n}\n\nmodule.exports.validate_config = validate_config;\n\nfunction eval_template(template,opts) {\n    Object.keys(opts).forEach(function(key) {\n        var pattern = '{'+key+'}';\n        while (template.indexOf(pattern) > -1) {\n            template = template.replace(pattern,opts[key]);\n        }\n    });\n    return template;\n}\n\n// url.resolve needs single trailing slash\n// to behave correctly, otherwise a double slash\n// may end up in the url which breaks requests\n// and a lacking slash may not lead to proper joining\nfunction fix_slashes(pathname) {\n    if (pathname.slice(-1) != '/') {\n        return pathname + '/';\n    }\n    return pathname;\n}\n\n// remove double slashes\n// note: path.normalize will not work because\n// it will convert forward to back slashes\nfunction drop_double_slashes(pathname) {\n    return pathname.replace(/\\/\\//g,'/');\n}\n\nfunction get_process_runtime(versions) {\n    var runtime = 'node';\n    if (versions['node-webkit']) {\n        runtime = 'node-webkit';\n    } else if (versions.electron) {\n        runtime = 'electron';\n    }\n    return runtime;\n}\n\nmodule.exports.get_process_runtime = get_process_runtime;\n\nvar default_package_name = '{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz';\nvar default_remote_path = '';\n\nmodule.exports.evaluate = function(package_json,options) {\n    options = options || {};\n    validate_config(package_json);\n    var v = package_json.version;\n    var module_version = semver.parse(v);\n    var runtime = options.runtime || get_process_runtime(process.versions);\n    var opts = {\n        name: package_json.name,\n        configuration: Boolean(options.debug) ? 'Debug' : 'Release',\n        debug: options.debug,\n        module_name: package_json.binary.module_name,\n        version: module_version.version,\n        prerelease: module_version.prerelease.length ? module_version.prerelease.join('.') : '',\n        build: module_version.build.length ? module_version.build.join('.') : '',\n        major: module_version.major,\n        minor: module_version.minor,\n        patch: module_version.patch,\n        runtime: runtime,\n        node_abi: get_runtime_abi(runtime,options.target),\n        target: options.target || '',\n        platform: options.target_platform || process.platform,\n        target_platform: options.target_platform || process.platform,\n        arch: options.target_arch || process.arch,\n        target_arch: options.target_arch || process.arch,\n        module_main: package_json.main,\n        toolset : options.toolset || '' // address https://github.com/mapbox/node-pre-gyp/issues/119\n    };\n    // support host mirror with npm config `--{module_name}_binary_host_mirror`\n    // e.g.: https://github.com/node-inspector/v8-profiler/blob/master/package.json#L25\n    // > npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/\n    var host = process.env['npm_config_' + opts.module_name + '_binary_host_mirror'] || package_json.binary.host;\n    opts.host = fix_slashes(eval_template(host,opts));\n    opts.module_path = eval_template(package_json.binary.module_path,opts);\n    // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably\n    if (options.module_root) {\n        // resolve relative to known module root: works for pre-binding require\n        opts.module_path = path.join(options.module_root,opts.module_path);\n    } else {\n        // resolve relative to current working directory: works for node-pre-gyp commands\n        opts.module_path = path.resolve(opts.module_path);\n    }\n    opts.module = path.join(opts.module_path,opts.module_name + '.node');\n    opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path,opts))) : default_remote_path;\n    var package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;\n    opts.package_name = eval_template(package_name,opts);\n    opts.staged_tarball = path.join('build/stage',opts.remote_path,opts.package_name);\n    opts.hosted_path = url.resolve(opts.host,opts.remote_path);\n    opts.hosted_tarball = url.resolve(opts.hosted_path,opts.package_name);\n    return opts;\n};\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/clean.js":"\"use strict\";\n\nmodule.exports = exports = clean;\n\nexports.usage = 'Removes the entire folder containing the compiled .node module';\n\nvar fs = require('fs');\nvar rm = require('rimraf');\nvar exists = require('fs').exists || require('path').exists;\nvar versioning = require('./util/versioning.js');\n\nfunction clean (gyp, argv, callback) {\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    var to_delete = opts.module_path;\n    exists(to_delete, function(found) {\n        if (found) {\n            if (!gyp.opts.silent_clean) console.log('['+package_json.name+'] Removing \"%s\"', to_delete);\n            return rm(to_delete, callback);\n        }\n        return callback();\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/configure.js":"\"use strict\";\n\nmodule.exports = exports = configure;\n\nexports.usage = 'Attempts to configure node-gyp or nw-gyp build';\n\nvar compile = require('./util/compile.js');\nvar handle_gyp_opts = require('./util/handle_gyp_opts.js');\n\nfunction configure(gyp, argv, callback) {\n    handle_gyp_opts(gyp,argv,function(err,result) {\n        var final_args = result.gyp.concat(result.pre);\n        // pull select node-gyp configure options out of the npm environ\n        var known_gyp_args = ['dist-url','python','nodedir','msvs_version'];\n        known_gyp_args.forEach(function(key) {\n            var val = gyp.opts[key] || gyp.opts[key.replace('-','_')];\n            if (val) {\n               final_args.push('--'+key+'='+val);\n            }\n        });\n        // --ensure=false tell node-gyp to re-install node development headers\n        // but it is only respected by node-gyp install, so we have to call install\n        // as a separate step if the user passes it\n        if (gyp.opts.ensure === false) {\n            var install_args = final_args.concat(['install','--ensure=false']);\n            compile.run_gyp(install_args,result.opts,function(err) {\n                if (err) return callback(err);\n                if (result.unparsed.length > 0) {\n                    final_args = final_args.\n                                  concat(['--']).\n                                  concat(result.unparsed);\n                }\n                compile.run_gyp(['configure'].concat(final_args),result.opts,function(err) {\n                    return callback(err);\n                });\n            });\n        } else {\n            if (result.unparsed.length > 0) {\n                final_args = final_args.\n                              concat(['--']).\n                              concat(result.unparsed);\n            }\n            compile.run_gyp(['configure'].concat(final_args),result.opts,function(err) {\n                return callback(err);\n            });\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/util/compile.js":"\"use strict\";\n\nmodule.exports = exports;\n\nvar fs = require('fs');\nvar path = require('path');\nvar win = process.platform == 'win32';\nvar existsSync = fs.existsSync || path.existsSync;\nvar cp = require('child_process');\n\n// try to build up the complete path to node-gyp\n/* priority:\n  - node-gyp on ENV:npm_config_node_gyp (https://github.com/npm/npm/pull/4887)\n  - node-gyp on NODE_PATH\n  - node-gyp inside npm on NODE_PATH (ignore on iojs)\n  - node-gyp inside npm beside node exe\n*/\nfunction which_node_gyp() {\n    var node_gyp_bin;\n    if (process.env.npm_config_node_gyp) {\n      try {\n          node_gyp_bin = process.env.npm_config_node_gyp;\n          if (existsSync(node_gyp_bin)) {\n              return node_gyp_bin;\n          }\n      } catch (err) { }\n    }\n    try {\n        var node_gyp_main = require.resolve('node-gyp');\n        node_gyp_bin = path.join(path.dirname(\n                                     path.dirname(node_gyp_main)),\n                                     'bin/node-gyp.js');\n        if (existsSync(node_gyp_bin)) {\n            return node_gyp_bin;\n        }\n    } catch (err) { }\n    if (process.execPath.indexOf('iojs') === -1) {\n        try {\n            var npm_main = require.resolve('npm');\n            node_gyp_bin = path.join(path.dirname(\n                                         path.dirname(npm_main)),\n                                         'node_modules/node-gyp/bin/node-gyp.js');\n            if (existsSync(node_gyp_bin)) {\n                return node_gyp_bin;\n            }\n        } catch (err) { }\n    }\n    var npm_base = path.join(path.dirname(\n                             path.dirname(process.execPath)),\n                             'lib/node_modules/npm/');\n    node_gyp_bin = path.join(npm_base, 'node_modules/node-gyp/bin/node-gyp.js');\n    if (existsSync(node_gyp_bin)) {\n        return node_gyp_bin;\n    }\n}\n\nmodule.exports.run_gyp = function(args,opts,callback) {\n    var shell_cmd = '';\n    var cmd_args = [];\n    if (opts.runtime && opts.runtime == 'node-webkit') {\n        shell_cmd = 'nw-gyp';\n        if (win) shell_cmd += '.cmd';\n    } else {\n        var node_gyp_path = which_node_gyp();\n        if (node_gyp_path) {\n            shell_cmd = process.execPath;\n            cmd_args.push(node_gyp_path);\n        } else {\n            shell_cmd = 'node-gyp';\n            if (win) shell_cmd += '.cmd';\n        }\n    }\n    var final_args = cmd_args.concat(args);\n    var cmd = cp.spawn(shell_cmd, final_args, {cwd: undefined, env: process.env, stdio: [ 0, 1, 2]});\n    cmd.on('error', function (err) {\n        if (err) {\n            return callback(new Error(\"Failed to execute '\" + shell_cmd + ' ' + final_args.join(' ') + \"' (\" + err + \")\"));\n        }\n        callback(null,opts);\n    });\n    cmd.on('close', function (code) {\n        if (code && code !== 0) {\n            return callback(new Error(\"Failed to execute '\" + shell_cmd + ' ' + final_args.join(' ') + \"' (\" + code + \")\"));\n        }\n        callback(null,opts);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js":"\"use strict\";\n\nmodule.exports = exports = handle_gyp_opts;\n\nvar fs = require('fs');\nvar versioning = require('./versioning.js');\n\n/*\n\nHere we gather node-pre-gyp generated options (from versioning) and pass them along to node-gyp.\n\nWe massage the args and options slightly to account for differences in what commands mean between\nnode-pre-gyp and node-gyp (e.g. see the difference between \"build\" and \"rebuild\" below)\n\nKeep in mind: the values inside `argv` and `gyp.opts` below are different depending on whether\nnode-pre-gyp is called directory, or if it is called in a `run-script` phase of npm.\n\nWe also try to preserve any command line options that might have been passed to npm or node-pre-gyp.\nBut this is fairly difficult without passing way to much through. For example `gyp.opts` contains all\nthe process.env and npm pushes a lot of variables into process.env which node-pre-gyp inherits. So we have\nto be very selective about what we pass through.\n\nFor example:\n\n`npm install --build-from-source` will give:\n\nargv == [ 'rebuild' ]\ngyp.opts.argv == { remain: [ 'install' ],\n  cooked: [ 'install', '--fallback-to-build' ],\n  original: [ 'install', '--fallback-to-build' ] }\n\n`./bin/node-pre-gyp build` will give:\n\nargv == []\ngyp.opts.argv == { remain: [ 'build' ],\n  cooked: [ 'build' ],\n  original: [ '-C', 'test/app1', 'build' ] }\n\n*/\n\n// select set of node-pre-gyp versioning info\n// to share with node-gyp\nvar share_with_node_gyp = [\n  'module',\n  'module_name',\n  'module_path',\n];\n\nfunction handle_gyp_opts(gyp, argv, callback) {\n\n    // Collect node-pre-gyp specific variables to pass to node-gyp\n    var node_pre_gyp_options = [];\n    // generate custom node-pre-gyp versioning info\n    var opts = versioning.evaluate(JSON.parse(fs.readFileSync('./package.json')), gyp.opts);\n    share_with_node_gyp.forEach(function(key) {\n        var val = opts[key];\n        if (val) {\n            node_pre_gyp_options.push('--' + key + '=' + val);\n        } else {\n            return callback(new Error(\"Option \" + key + \" required but not found by node-pre-gyp\"));\n        }\n    });\n\n    // Collect options that follow the special -- which disables nopt parsing\n    var unparsed_options = [];\n    var double_hyphen_found = false;\n    gyp.opts.argv.original.forEach(function(opt) {\n        if (double_hyphen_found) {\n            unparsed_options.push(opt);\n        }\n        if (opt == '--') {\n            double_hyphen_found = true;\n        }\n    });\n\n    // We try respect and pass through remaining command\n    // line options (like --foo=bar) to node-gyp\n    var cooked = gyp.opts.argv.cooked;\n    var node_gyp_options = [];\n    cooked.forEach(function(value) {\n        if (value.length > 2 && value.slice(0,2) == '--') {\n            var key = value.slice(2);\n            var val = cooked[cooked.indexOf(value)+1];\n            if (val && val.indexOf('--') === -1) { // handle '--foo=bar' or ['--foo','bar']\n                node_gyp_options.push('--' + key + '=' + val);\n            } else { // pass through --foo\n                node_gyp_options.push(value);\n            }\n        }\n    });\n\n    var result = {'opts':opts,'gyp':node_gyp_options,'pre':node_pre_gyp_options,'unparsed':unparsed_options};\n    return callback(null,result);\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/info.js":"\"use strict\";\n\nmodule.exports = exports = unpublish;\n\nexports.usage = 'Lists all published binaries (requires aws-sdk)';\n\nvar fs = require('fs');\nvar log = require('npmlog');\nvar versioning = require('./util/versioning.js');\nvar s3_setup = require('./util/s3_setup.js');\nvar config = require('rc')(\"node_pre_gyp\",{acl:\"public-read\"});\n\nfunction unpublish(gyp, argv, callback) {\n    var AWS = require(\"aws-sdk\");\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    s3_setup.detect(opts.hosted_path,config);\n    AWS.config.update(config);\n    var s3 =  new AWS.S3();\n    var s3_opts = {  Bucket: config.bucket,\n                     Prefix: config.prefix\n                  };\n    s3.listObjects(s3_opts, function(err, meta){\n        if (err && err.code == 'NotFound') {\n            return callback(new Error('['+package_json.name+'] Not found: https://' + s3_opts.Bucket + '.s3.amazonaws.com/'+config.prefix));\n        } else if(err) {\n            return callback(err);\n        } else {\n            log.verbose(JSON.stringify(meta,null,1));\n            if (meta && meta.Contents) {\n                meta.Contents.forEach(function(obj) {\n                    console.log(obj.Key);\n                });\n            } else {\n                console.error('['+package_json.name+'] No objects found at https://' + s3_opts.Bucket + '.s3.amazonaws.com/'+config.prefix );\n            }\n            return callback();\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/util/s3_setup.js":"\"use strict\";\n\nmodule.exports = exports;\n\nvar url = require('url');\n\nvar URI_REGEX=\"^(.*)\\.(s3(?:-.*)?)\\.amazonaws\\.com$\";\n\nmodule.exports.detect = function(to,config) {\n    var uri = url.parse(to);\n    var hostname_matches = uri.hostname.match(URI_REGEX);\n    config.prefix = (!uri.pathname || uri.pathname == '/') ? '' : uri.pathname.replace('/','');\n    if(!hostname_matches) {\n        return;\n    }\n    if (!config.bucket) {\n        config.bucket = hostname_matches[1];\n    }\n    if (!config.region) {\n        var s3_domain = hostname_matches[2];\n        if (s3_domain.slice(0,3) == 's3-' &&\n            s3_domain.length >= 3) {\n            // it appears the region is explicit in the url\n            config.region = s3_domain.replace('s3-','');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/install.js":"\"use strict\";\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nvar fs = require('fs');\nvar path = require('path');\nvar zlib = require('zlib');\nvar log = require('npmlog');\nvar existsAsync = fs.exists || path.exists;\nvar versioning = require('./util/versioning.js');\nvar testbinary = require('./testbinary.js');\nvar clean = require('./clean.js');\n\nvar npgVersion = 'unknown';\ntry {\n    // Read own package.json to get the current node-pre-pyp version.\n    var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n    npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {}\n\nfunction download(uri,opts,callback) {\n    log.http('GET', uri);\n\n    var req = null;\n\n    // Try getting version info from the currently running npm.\n    var envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n    var requestOpts = {\n        uri: uri.replace('+','%2B'),\n        headers: {\n          'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n        }\n    };\n\n    if (opts.cafile) {\n        try {\n            requestOpts.ca = fs.readFileSync(opts.cafile);\n        } catch (e) {\n            return callback(e);\n        }\n    } else if (opts.ca) {\n        requestOpts.ca = opts.ca;\n    }\n\n    var proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n    if (proxyUrl) {\n      if (/^https?:\\/\\//i.test(proxyUrl)) {\n        log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n        requestOpts.proxy = proxyUrl;\n      } else {\n        log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n      }\n    }\n    try {\n        req = require('request')(requestOpts);\n    } catch (e) {\n        return callback(e);\n    }\n    if (req) {\n      req.on('response', function (res) {\n        log.http(res.statusCode, uri);\n      });\n    }\n    return callback(null,req);\n}\n\nfunction place_binary(from,to,opts,callback) {\n    download(from,opts,function(err,req) {\n        if (err) return callback(err);\n        if (!req) return callback(new Error(\"empty req\"));\n        var badDownload = false;\n        var extractCount = 0;\n        var gunzip = zlib.createGunzip();\n        var extracter = require('tar').Extract({ path: to, strip: 1});\n\n        function afterTarball(err) {\n            if (err) return callback(err);\n            if (badDownload) return callback(new Error(\"bad download\"));\n            if (extractCount === 0) {\n                return callback(new Error('There was a fatal problem while downloading/extracting the tarball'));\n            }\n            log.info('tarball', 'done parsing tarball');\n            callback();\n        }\n\n        function filter_func(entry) {\n            // ensure directories are +x\n            // https://github.com/mapnik/node-mapnik/issues/262\n            entry.props.mode |= (entry.props.mode >>> 2) & parseInt('0111',8);\n            log.info('install','unpacking ' + entry.path);\n            extractCount++;\n        }\n\n        gunzip.on('error', callback);\n        extracter.on('entry', filter_func);\n        extracter.on('error', callback);\n        extracter.on('end', afterTarball);\n\n        req.on('error', function(err) {\n            badDownload = true;\n            return callback(err);\n        });\n\n        req.on('close', function () {\n            if (extractCount === 0) {\n                return callback(new Error('Connection closed while downloading tarball file'));\n            }\n        });\n\n        req.on('response', function(res) {\n            if (res.statusCode !== 200) {\n                badDownload = true;\n                var err = new Error(res.statusCode + ' status code downloading tarball ' + from);\n                err.statusCode = res.statusCode;\n                return callback(err);\n            }\n            // start unzipping and untaring\n            req.pipe(gunzip).pipe(extracter);\n        });\n    });\n}\n\nfunction do_build(gyp,argv,callback) {\n  gyp.todo.push( { name: 'build', args: ['rebuild'] } );\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err,opts,package_json) {\n    var fallback_message = ' (falling back to source compile with node-gyp)';\n    var full_message = \"Pre-built binaries not found for \" + package_json.name + \"@\" + package_json.version;\n    full_message += \" and \" + opts.runtime + \"@\" + (opts.target || process.versions.node) + \" (\" + opts.node_abi + \" ABI)\";\n    full_message += fallback_message;\n    log.error(\"Tried to download(\" + err.statusCode + \"): \" + opts.hosted_tarball);\n    log.error(full_message);\n    log.http(err.message);\n}\n\nfunction install(gyp, argv, callback) {\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n    var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n    var should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n    var no_rollback = gyp.opts.hasOwnProperty('rollback') && gyp.opts.rollback === false;\n    if (should_do_source_build) {\n        log.info('build','requesting source compile');\n        return do_build(gyp,argv,callback);\n    } else {\n        var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n        var should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n        // but allow override from npm\n        if (process.env.npm_config_argv) {\n            var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n            var match = cooked.indexOf(\"--fallback-to-build\");\n            if (match > -1 && cooked.length > match && cooked[match+1] == \"false\") {\n                should_do_fallback_build = false;\n                log.info('install','Build fallback disabled via npm flag: --fallback-to-build=false');\n            }\n        }\n        var opts;\n        try {\n            opts = versioning.evaluate(package_json, gyp.opts);\n        } catch (err) {\n            return callback(err);\n        }\n\n        opts.ca = gyp.opts.ca;\n        opts.cafile = gyp.opts.cafile;\n\n        var from = opts.hosted_tarball;\n        var to = opts.module_path;\n        var binary_module = path.join(to,opts.module_name + '.node');\n        if (existsAsync(binary_module,function(found) {\n            if (found && !update_binary) {\n                testbinary(gyp, argv, function(err) {\n                    if (err) {\n                        console.error('['+package_json.name+'] ' + err.message);\n                        log.error(\"Testing local pre-built binary failed, attempting to re-download\");\n                        place_binary(from,to,opts,function(err) {\n                            if (err) {\n                                if (should_do_fallback_build) {\n                                    print_fallback_error(err,opts,package_json);\n                                    return do_build(gyp,argv,callback);\n                                } else {\n                                    return callback(err);\n                                }\n                            } else {\n                                console.log('['+package_json.name+'] Success: \"' + binary_module + '\" is reinstalled via remote');\n                                return callback();\n                            }\n                        });\n                    } else {\n                        console.log('['+package_json.name+'] Success: \"' + binary_module + '\" already installed');\n                        console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n                        return callback();\n                    }\n                });\n            } else {\n                if (!update_binary) log.info('check','checked for \"' + binary_module + '\" (not found)');\n                place_binary(from,to,opts,function(err) {\n                    if (err && should_do_fallback_build) {\n                        print_fallback_error(err,opts,package_json);\n                        return do_build(gyp,argv,callback);\n                    } else if (err) {\n                        return callback(err);\n                    } else {\n                        testbinary(gyp, argv, function(err) {\n                            if (err) {\n                                if (no_rollback) {\n                                    return callback(err);\n                                }\n                                gyp.opts.silent_clean = true;\n                                clean(gyp, argv, function(error) {\n                                    if (error) console.log(error);\n                                    if (should_do_fallback_build) {\n                                        console.error('['+package_json.name+'] ' + err.message);\n                                        log.error(\"Testing pre-built binary failed, attempting to source compile\");\n                                        return do_build(gyp,argv,callback);\n                                    } else {\n                                        return callback(err);\n                                    }\n                                });\n                            } else {\n                                console.log('['+package_json.name+'] Success: \"' + binary_module + '\" is installed via remote');\n                                return callback();\n                            }\n                        });\n                    }\n                });\n            }\n        }));\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/testbinary.js":"\"use strict\";\n\nmodule.exports = exports = testbinary;\n\nexports.usage = 'Tests that the binary.node can be required';\n\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar cp = require('child_process');\nvar versioning = require('./util/versioning.js');\nvar path = require('path');\n\nfunction testbinary(gyp, argv, callback) {\n    var args = [];\n    var options = {};\n    var shell_cmd = process.execPath;\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    // ensure on windows that / are used for require path\n    var binary_module = opts.module.replace(/\\\\/g, '/');\n    var nw = (opts.runtime && opts.runtime === 'node-webkit');\n    if ((process.arch != opts.target_arch) ||\n        (process.platform != opts.target_platform)) {\n        var msg = \"skipping validation since host platform/arch (\";\n        msg += process.platform+'/'+process.arch+\")\";\n        msg += \" does not match target (\";\n        msg += opts.target_platform+'/'+opts.target_arch+\")\";\n        log.info('validate', msg);\n        return callback();\n    }\n    if (nw) {\n        options.timeout = 5000;\n        if (process.platform === 'darwin') {\n            shell_cmd = 'node-webkit';\n        } else if (process.platform === 'win32') {\n            shell_cmd = 'nw.exe';\n        } else {\n            shell_cmd = 'nw';\n        }\n        var modulePath = path.resolve(binary_module);\n        var appDir = path.join(__dirname, 'util', 'nw-pre-gyp');\n        args.push(appDir);\n        args.push(modulePath);\n        log.info(\"validate\",\"Running test command: '\" + shell_cmd + ' ' + args.join(' ') + \"'\");\n        cp.execFile(shell_cmd, args, options, function(err, stdout, stderr) {\n            // check for normal timeout for node-webkit\n            if (err) {\n                if (err.killed === true && err.signal && err.signal.indexOf('SIG') > -1) {\n                    return callback();\n                }\n                var stderrLog = stderr.toString();\n                log.info('stderr', stderrLog);\n                if( /^\\s*Xlib:\\s*extension\\s*\"RANDR\"\\s*missing\\s*on\\s*display\\s*\":\\d+\\.\\d+\"\\.\\s*$/.test(stderrLog) ){\n                    log.info('RANDR', 'stderr contains only RANDR error, ignored');\n                    return callback();\n                }\n                return callback(err);\n            }\n            return callback();\n        });\n        return;\n    }\n    args.push('--eval');\n    args.push(\"'require(\\\\'\" + binary_module.replace(/\\'/g, '\\\\\\'') +\"\\\\')'\");\n    log.info(\"validate\",\"Running test command: '\" + shell_cmd + ' ' + args.join(' ') + \"'\");\n    cp.execFile(shell_cmd, args, options, function(err, stdout, stderr) {\n        if (err) {\n            return callback(err, { stdout:stdout, stderr:stderr});\n        }\n        return callback();\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/package.js":"\"use strict\";\n\nmodule.exports = exports = _package;\n\nexports.usage = 'Packs binary (and enclosing directory) into locally staged tarball';\n\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar versioning = require('./util/versioning.js');\nvar write = require('fs').createWriteStream;\nvar existsAsync = fs.exists || path.exists;\nvar mkdirp = require('mkdirp');\n\nfunction _package(gyp, argv, callback) {\n    var pack = require('tar-pack').pack;\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    var from = opts.module_path;\n    var binary_module = path.join(from,opts.module_name + '.node');\n    existsAsync(binary_module,function(found) {\n        if (!found) {\n            return callback(new Error(\"Cannot package because \" + binary_module + \" missing: run `node-pre-gyp rebuild` first\"));\n        }\n        var tarball = opts.staged_tarball;\n        var filter_func = function(entry) {\n            // ensure directories are +x\n            // https://github.com/mapnik/node-mapnik/issues/262\n            log.info('package','packing ' + entry.path);\n            return true;\n        };\n        mkdirp(path.dirname(tarball),function(err) {\n            if (err) throw err;\n            pack(from, { filter: filter_func })\n             .pipe(write(tarball))\n             .on('error', function(err) {\n                if (err)  console.error('['+package_json.name+'] ' + err.message);\n                return callback(err);\n             })\n             .on('close', function() {\n                log.info('package','Binary staged at \"' + tarball + '\"');\n                return callback();\n             });\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/publish.js":"\"use strict\";\n\nmodule.exports = exports = publish;\n\nexports.usage = 'Publishes pre-built binary (requires aws-sdk)';\n\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar versioning = require('./util/versioning.js');\nvar s3_setup = require('./util/s3_setup.js');\nvar existsAsync = fs.exists || path.exists;\nvar url = require('url');\nvar config = require('rc')(\"node_pre_gyp\",{acl:\"public-read\"});\n\nfunction publish(gyp, argv, callback) {\n    var AWS = require(\"aws-sdk\");\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    var tarball = opts.staged_tarball;\n    existsAsync(tarball,function(found) {\n        if (!found) {\n            return callback(new Error(\"Cannot publish because \" + tarball + \" missing: run `node-pre-gyp package` first\"));\n        }\n        log.info('publish', 'Detecting s3 credentials');\n        s3_setup.detect(opts.hosted_path,config);\n        var key_name = url.resolve(config.prefix,opts.package_name);\n        log.info('publish', 'Authenticating with s3');\n        AWS.config.update(config);\n        var s3 =  new AWS.S3();\n        var s3_opts = {  Bucket: config.bucket,\n                         Key: key_name\n                      };\n        var remote_package = 'https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key;\n        log.info('publish', 'Checking for existing binary at ' + remote_package);\n        s3.headObject(s3_opts, function(err, meta){\n            if (meta) log.info('publish', JSON.stringify(meta));\n            if (err && err.code == 'NotFound') {\n                // we are safe to publish because\n                // the object does not already exist\n                log.info('publish', 'Preparing to put object');\n                var s3_put = new AWS.S3();\n                var s3_put_opts = {  ACL: config.acl,\n                                     Body: fs.createReadStream(tarball),\n                                     Bucket: config.bucket,\n                                     Key: key_name\n                                  };\n                log.info('publish', 'Putting object');\n                try {\n                    s3_put.putObject(s3_put_opts, function(err, resp){\n                        log.info('publish', 'returned from putting object');\n                        if(err) {\n                           log.info('publish', 's3 putObject error: \"' + err + '\"');\n                           return callback(err);\n                        }\n                        if (resp) log.info('publish', 's3 putObject response: \"' + JSON.stringify(resp) + '\"');\n                        log.info('publish', 'successfully put object');\n                        console.log('['+package_json.name+'] published to ' + remote_package);\n                        return callback();\n                    });\n              } catch (err) {\n                   log.info('publish', 's3 putObject error: \"' + err + '\"');\n                   return callback(err);\n              }\n            } else if (err) {\n                log.info('publish', 's3 headObject error: \"' + err + '\"');\n                return callback(err);\n            } else {\n                log.error('publish','Cannot publish over existing version');\n                log.error('publish',\"Update the 'version' field in package.json and try again\");\n                log.error('publish','If the previous version was published in error see:');\n                log.error('publish','\\t node-pre-gyp unpublish');\n                return callback(new Error('Failed publishing to ' + remote_package));\n            }\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/rebuild.js":"\"use strict\";\n\nmodule.exports = exports = rebuild;\n\nexports.usage = 'Runs \"clean\" and \"build\" at once';\n\nfunction rebuild (gyp, argv, callback) {\n  gyp.todo.unshift(\n      { name: 'clean', args: [] },\n      { name: 'build', args: ['rebuild'] }\n  );\n  process.nextTick(callback);\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/reinstall.js":"\"use strict\";\n\nmodule.exports = exports = rebuild;\n\nexports.usage = 'Runs \"clean\" and \"install\" at once';\n\nfunction rebuild (gyp, argv, callback) {\n  gyp.todo.unshift(\n      { name: 'clean', args: [] },\n      { name: 'install', args: [] }\n  );\n  process.nextTick(callback);\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/reveal.js":"\"use strict\";\n\nmodule.exports = exports = reveal;\n\nexports.usage = 'Reveals data on the versioned binary';\n\nvar fs = require('fs');\nvar versioning = require('./util/versioning.js');\n\nfunction unix_paths(key, val) {\n    return val && val.replace ? val.replace(/\\\\/g, '/') : val;\n}\n\nfunction reveal(gyp, argv, callback) {\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    var hit = false;\n    // if a second arg is passed look to see\n    // if it is a known option\n    //console.log(JSON.stringify(gyp.opts,null,1))\n    var remain = gyp.opts.argv.remain.pop();\n    if (remain && opts.hasOwnProperty(remain)) {\n        console.log(opts[remain].replace(/\\\\/g, '/'));\n        hit = true;\n    }\n    // otherwise return all options as json\n    if (!hit) {\n        console.log(JSON.stringify(opts,unix_paths,2));\n    }\n    return callback();\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/testpackage.js":"\"use strict\";\n\nmodule.exports = exports = testpackage;\n\nexports.usage = 'Tests that the staged package is valid';\n\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar existsAsync = fs.exists || path.exists;\nvar versioning = require('./util/versioning.js');\nvar testbinary = require('./testbinary.js');\nvar read = require('fs').createReadStream;\nvar zlib = require('zlib');\n\nfunction testpackage(gyp, argv, callback) {\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    var tarball = opts.staged_tarball;\n    existsAsync(tarball, function(found) {\n        if (!found) {\n            return callback(new Error(\"Cannot test package because \" + tarball + \" missing: run `node-pre-gyp package` first\"));\n        }\n        var to = opts.module_path;\n        var gunzip = zlib.createGunzip();\n        var extracter = require('tar').Extract({ path: to, strip: 1 });\n        function filter_func(entry) {\n            // ensure directories are +x\n            // https://github.com/mapnik/node-mapnik/issues/262\n            entry.props.mode |= (entry.props.mode >>> 2) & parseInt('0111',8);\n            log.info('install','unpacking ' + entry.path);\n        }\n        gunzip.on('error', callback);\n        extracter.on('error', callback);\n        extracter.on('entry', filter_func);\n        extracter.on('end', function(err) {\n            if (err) return callback(err);\n            testbinary(gyp,argv,function(err) {\n                if (err) {\n                    return callback(err);\n                } else {\n                    console.log('['+package_json.name+'] Package appears valid');\n                    return callback();\n                }\n            });\n        });\n        read(tarball).pipe(gunzip).pipe(extracter);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-pre-gyp/node_modules/node-pre-gyp/lib/unpublish.js":"\"use strict\";\n\nmodule.exports = exports = unpublish;\n\nexports.usage = 'Unpublishes pre-built binary (requires aws-sdk)';\n\nvar fs = require('fs');\nvar log = require('npmlog');\nvar versioning = require('./util/versioning.js');\nvar s3_setup = require('./util/s3_setup.js');\nvar url = require('url');\nvar config = require('rc')(\"node_pre_gyp\",{acl:\"public-read\"});\n\nfunction unpublish(gyp, argv, callback) {\n    var AWS = require(\"aws-sdk\");\n    var package_json = JSON.parse(fs.readFileSync('./package.json'));\n    var opts = versioning.evaluate(package_json, gyp.opts);\n    s3_setup.detect(opts.hosted_path,config);\n    AWS.config.update(config);\n    var key_name = url.resolve(config.prefix,opts.package_name);\n    var s3 =  new AWS.S3();\n    var s3_opts = {  Bucket: config.bucket,\n                     Key: key_name\n                  };\n    s3.headObject(s3_opts, function(err, meta) {\n        if (err && err.code == 'NotFound') {\n            console.log('['+package_json.name+'] Not found: https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key);\n            return callback();\n        } else if(err) {\n            return callback(err);\n        } else {\n            log.info('unpublish', JSON.stringify(meta));\n            s3.deleteObject(s3_opts, function(err, resp) {\n                if (err) return callback(err);\n                log.info(JSON.stringify(resp));\n                console.log('['+package_json.name+'] Success: removed https://' + s3_opts.Bucket + '.s3.amazonaws.com/' + s3_opts.Key);\n                return callback();\n            });\n        }\n    });\n}\n"}